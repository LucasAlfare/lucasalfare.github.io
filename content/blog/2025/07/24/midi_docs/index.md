+++
date = '2025-07-24T00:00:00-03:00'
title = 'Documenta√ß√£o MIDI pt-BR'
summary = 'Minha pr√≥pria documenta√ß√£o do formato bin√°rio MIDI com linguagem acess√≠vel.'
type = 'blog'
+++

> _**Nota:**_ _Ainda em constru√ß√£o!_  # √çndice  - [1. Apresenta√ß√£o](#1-apresenta√ß√£o) - [2. O que √© MIDI?](#2-o-que-√©-midi) - [3. Usos de MIDI](#3-usos-de-midi) - [4. Arquivos](#4-arquivos) - [5. No√ß√µes de leitura](#5-no√ß√µes-de-leitura)     - [5.1 Ponto de partida](#51-ponto-de-partida)     - [5.2 Tipo num√©ricos](#52-tipo-num√©ricos)     - [5.3 Bin√°rio, Decimal, Hexadecimal](#53-bin√°rio-decimal-hexadecimal)     - [5.4 N√∫meros positivos e N√∫meros negativos](#54-n√∫meros-positivos-e-n√∫meros-negativos)     - [5.5 _"MSB"_ e _"LSB"_](#55-msb-e-lsb)     - [5.6 N√∫meros se transformam em informa√ß√£o](#56-n√∫meros-se-transformam-em-informa√ß√£o)     - [5.7 O tal _"endianess"_](#57-o-tal-endianess)     - [5.8 Opera√ß√µes de leitura](#58-opera√ß√µes-de-leitura)         - [5.8.1 Juntar dois n√∫meros](#581-juntar-dois-n√∫meros) - [6. Estrutura MIDI](#6-estrutura-midi)     - [6.1 _Chunks_](#61-chunks)         - [6.1.1 _Chunk_ de cabe√ßalho (_header_)](#611-chunk-de-cabe√ßalho-header)             - [6.1.1.1 Assinatura (_MThd_)](#6111-assinatura-MThd)             - [6.1.1.2 Tamanho do _header_](#6112-tamanho-do-header)             - [6.1.1.3 Formato do arquivo](#6113-formato-do-arquivo)             - [6.1.1.4 N√∫mero de trilhas (_`ntrks`_)](#6114-n√∫mero-de-trilhas-ntrks)  # 1. Apresenta√ß√£o  Opa, pessoal! Neste artigo, vou tentar descrever a especifica√ß√£o para arquivos MIDI (extens√£o `.mid`). Mas n√£o quero uma descri√ß√£o resumida ou que omita coisas; minha inten√ß√£o √© trazer a especifica√ß√£o em uma linguagem mais tranquila e f√°cil de entender.  Tamb√©m vou tentar escrever este texto de forma acess√≠vel tanto para quem j√° tem costume com esse tipo de tema quanto para quem nunca mexeu com interpreta√ß√£o de arquivos antes. Por conta disso, este conte√∫do poder√° ser usado como material introdut√≥rio justamente para esse t√≥pico de leitura de arquivos. Tentarei fazer isso deixando algumas notas ou tornando o texto um pouco mais explicativo, indo al√©m de simplesmente descrever a estrutura do arquivo MIDI.  Al√©m disso, farei o poss√≠vel para usar exemplos de c√≥digo em *pseudo-c√≥digo*, afinal, ver c√≥digo √© algo que sempre ajuda a entender melhor alguns processos, pois a linguagem da programa√ß√£o √© universal.  Sendo assim, meu objetivo com este material √© simplesmente documentar esse formato, sobretudo focando em fornecer uma fonte em portugu√™s, j√° que esse tipo de conte√∫do √© bem escasso neste idioma.  Por fim, mesmo esse formato MIDI sendo "relativamente datado" (antigo), ele ainda √© usado _pra caramba_ nos dias de hoje! Simplesmente jogos, aplica√ß√µes que lidam com efeitos sonoros, projetos no √¢mbito da _programa√ß√£o musical_ e uma outra grande quantidade de contextos de fato usam MIDI ‚Äî e isso acontece justamente pelo fato de o MIDI ser um formato absurdamente leve e port√°vel.  Como veremos ao longo do nosso material, MIDI n√£o √© necessariamente trivial de ser _analisado_, mas isso n√£o significa que esse formato n√£o seja simples.  # 2. O que √© MIDI?  *MIDI* basicamente se refere a um formato que serve para lidar com **sons** de forma totalmente digital.  > _**Q.:**_ _Mas... o que exatamente isso quer dizer?_  Isso significa que a ideia do formato √© que os dados sobre sons sejam mais como "informa√ß√µes" do que uma "representa√ß√£o" sonora propriamente dita.  Para entendermos melhor, vamos pensar em um arquivo de √°udio tradicional, como `WAVE` ou `MP3`. Esses arquivos t√™m a inten√ß√£o de guardar informa√ß√µes sobre as pr√≥prias frequ√™ncias de som, permitindo que algum hardware de √°udio possa ser alimentado com tais informa√ß√µes e desencadear sons. Obviamente, aqui eu resumi pra caramba, mas, para efeito comparativo, est√° bom. J√° o MIDI basicamente guarda informa√ß√µes como *"nota X come√ßou a ser tocada no momento Y"*, o que √© uma informa√ß√£o que um dispositivo de hardware de som jamais seria capaz de entender por si s√≥.  Portanto, em resumo, o MIDI demonstra dados sobre *eventos*, enquanto outros formatos demonstram dados sobre *frequ√™ncias*.  No contexto pr√°tico, MIDI serve basicamente pra descrever as notas musicais de uma m√∫sica. Ou seja, artistas e produtores musicais usam esse formato pra escrever uma m√∫sica em baixo n√≠vel, sendo esse n√≠vel o "n√≠vel de nota".  Existe algumas outras coisas que podem ser gravadas no arquivo MIDI al√©m das notas propriamente ditas, como informa√ß√£o sobre _tempo_/_andamento_, informa√ß√µes textuais, _letras_ e etc.  Devido a isto, talvez alguns pontos desta documenta√ß√£o n√£o sejam amigavelmente acess√≠veis para leitores _n√£o-m√∫sicos_, entretanto, como programadores, acredito que o material deva ser relativamente tranquilo para ser consumido mesmo por quem seja leigo em teoria musical, visto a pr√≥pria linguagem tranquila no qual o material est√° escrito.  # 3. Usos de MIDI  MIDI √© um formato absurdamente antigo. Por exemplo, a documenta√ß√£o que estou usando como base para escrever este artigo tem *¬©Copyright* do ano de 1999. Por√©m, segundo o [site oficial do projeto](https://midi.org/specs), a vers√£o 1.0 √© datada de 1983. Dessa forma, esse formato tem sido usado ao longo de d√©cadas e, devido √† sua extrema "simplicidade", ainda √© utilizado at√© hoje.  Mas, contrariando o que muitos podem pensar, MIDI n√£o √© um formato que serve apenas para escrever arquivos; ele tamb√©m √© um protocolo de comunica√ß√£o entre determinados dispositivos f√≠sicos e algum software. Por exemplo, controladores MIDI podem ser simplesmente conectados ao computador e receber dados provenientes desses dispositivos, desde que consigam entender o formato MIDI. Da mesma forma, os controladores podem enviar sinais espec√≠ficos por seus *outputs*, compat√≠veis com a especifica√ß√£o.  Neste artigo, quero focar no uso do MIDI para escrever arquivos.  # 4. Arquivos  Como ficou estabelecido, os arquivos MIDI guardam informa√ß√µes como *"nota X come√ßou a ser tocada no momento Y"*. Por√©m, tais informa√ß√µes n√£o s√£o gravadas dentro de um arquivo essencialmente em formato de texto leg√≠vel para n√≥s, humanos, mas sim em *bytes* puros. Logo, arquivos MIDI s√£o arquivos "bin√°rios".  > **Nota:** Todo e qualquer arquivo √© bin√°rio. Por√©m, existem arquivos para os quais damos um significado padr√£o aos seus bytes, tabelando-os como caracteres visuais, formando assim os formatos do tipo "texto". No entanto, at√© os arquivos em formatos de texto tamb√©m s√£o formados por bytes puros; a diferen√ßa est√° apenas na forma como interpretamos esses bytes.  # 5. No√ß√µes de leitura  Nas se√ß√µes a seguir, vou fazer uma "breve" introdu√ß√£o sobre leitura de arquivos em geral. Vamos ver detalhes sobre como exatamente devemos lidar com essa coisa toda de "bytes", numa perspectiva em que estejamos fazendo a leitura diretamente a partir dos bytes puros.  √â importante lembrar que todos esses conceitos basicamente j√° existem por padr√£o em bibliotecas das pr√≥prias linguagens de programa√ß√£o. Ou seja, os t√≥picos a seguir v√£o servir justamente para que entendamos o que exatamente est√° acontecendo com os n√∫meros quando realizamos tais opera√ß√µes.  Fazer essas coisas na m√£o ‚Äî ou seja, sem necessariamente usar os recursos que j√° v√™m prontos nas linguagens ‚Äî n√£o √© algo ruim. Afinal, na maioria dos contextos, essas opera√ß√µes s√£o absurdamente simples para os computadores modernos de hoje em dia. Portanto, √© altamente recomend√°vel que, caso voc√™ seja iniciante, implemente essas coisas do absoluto zero; o aprendizado se tornar√° muito mais satisfat√≥rio!  ## 5.1 Ponto de partida  Sabendo disso, √© importante entendermos como exatamente devemos proceder para ler um arquivo bin√°rio bruto. Essa introdu√ß√£o vai nos ajudar a compreender a forma como iremos estruturar o formato propriamente dito.  Para lermos um arquivo em um formato n√£o convencional (ou seja, que n√£o √© baseado em texto) diretamente pelos seus bytes, podemos come√ßar carregando todos os bytes do arquivo em alguma estrutura de uma linguagem de programa√ß√£o, como uma lista ou um array. Todas as linguagens de programa√ß√£o modernas oferecem suporte para isso, mas, em um exemplo de pseudo-c√≥digo, poderia ser algo como:  ``` bytes_arquivo = carregarBytes("meu_arquivo_midi.mid") ```  A seguir, veremos mais t√≥picos explicando detalhes sobre a leitura de arquivos.  ## 5.2 Tipo num√©ricos  Outro conceito importante sobre a leitura de arquivos bin√°rios √© que devemos entender, de uma vez por todas, o que de fato s√£o esses *"bytes"*.  Quando nos referimos a "bytes", estamos falando de nada mais, nada menos que n√∫meros inteiros. Sim, exatamente, simplesmente n√∫meros. Por√©m, o termo "byte" nos indica que esses n√∫meros t√™m um "tamanho" espec√≠fico.  No caso de *1 byte*, os n√∫meros podem ir de `0` a `255`. Como voc√™ pode ver, n√£o √© poss√≠vel armazenar um n√∫mero maior que `255` dentro de 1 byte.  Nesse ponto, isso pode parecer estranho, especialmente se voc√™ nunca teve contato com linguagens de programa√ß√£o que possuem *tipagem forte* e *est√°tica*, ou seja, linguagens que exigem que voc√™ declare explicitamente o tipo da vari√°vel ou que definem o tipo da vari√°vel por infer√™ncia.  Exemplos de linguagens que n√£o exigem manipula√ß√£o expl√≠cita dos tipos das vari√°veis incluem `JavaScript` e `Python`. J√° outras linguagens, como `Java` e `C++`, obrigatoriamente requerem que especifiquemos os tipos das vari√°veis.  Se voc√™ programa apenas em JavaScript, por exemplo, entender sobre tamanhos de n√∫meros pode parecer algo novo. Afinal, quando escrevemos um n√∫mero em JavaScript, ele automaticamente √© definido como sendo do tipo `Number`, o que √© algo muito abstrato. Mas, para efeitos de curiosidade, linguagens como JavaScript s√£o escritas em cima de outras linguagens, normalmente `C`/`C++`, as quais tratam tipos explicitamente.  Sabendo disso, os *bytes* s√£o simplesmente n√∫meros desse tipo. Um arquivo, seja ele qual for, √© composto por um monte desses *bytes*, um atr√°s do outro, o que comprova que podemos carreg√°-los em um array, uma estrutura comum para sequ√™ncias.  Al√©m disso, vale lembrar que mencionei que `1 byte = 0 a 255`, por√©m esses n√∫meros est√£o escritos no formato "decimal". Mas por que exatamente 1 byte pode armazenar no m√°ximo 255? Isso acontece porque o tamanho dos n√∫meros √© determinado pela quantidade de **bits** que cada tipo pode guardar!  Byte √© um tipo que pode armazenar no m√°ximo **8 bits**, e se lembrarmos que bits s√£o apenas *zeros* ou *uns*, temos o seguinte:  ``` 1 byte = 00000000 a 11111111 ```  Perceba que, em vez de usar a representa√ß√£o decimal dos n√∫meros (0 a 255), utilizei uma representa√ß√£o **bin√°ria**. Dessa forma, podemos visualizar diretamente os bits dos n√∫meros e entender por que 1 byte pode armazenar, no m√°ximo, o n√∫mero 255, que em bin√°rio √© `11111111`!  > _**Nota:**_ A leitura desses n√∫meros bin√°rios, tipo o `11111111` acima, seria algo como "um um um um...", afinal n√£o devemos pensar nessa sequ√™ncia de n√∫meros `1` como sendo um n√∫mero decimal. Ou seja, √© **errado** olhar pra esse n√∫mero e pensar nele como sendo _"onze milh√µes cento e onze mil cento e onze"_. Mais adiante, veremos como podemos diferenciar e evidenciar se estamos falando de um n√∫mero bin√°rio ou n√£o.  Temos, ent√£o, v√°rios outros tipos de n√∫meros: - `byte`: como vimos, guarda no m√°ximo 8 bits; - `short`: guarda no m√°ximo 16 bits; - `int`: guarda no m√°ximo 32 bits; - `long`: guarda no m√°ximo 64 bits.  H√° tamb√©m o tipo `boolean`, que armazena apenas 1 √∫nico bit. Esse tipo √© t√£o simples que o usamos para representar o famoso "verdadeiro" (bit `1`) ou "falso" (bit `0`).  Existe tamb√©m o tipo `char`, que, basicamente, √© a mesma coisa que `byte`, mas semanticamente √© utilizado para armazenar valores que representem caracteres.  ## 5.3 Bin√°rio, Decimal, Hexadecimal  Demos uma pincelada sobre bin√°rio no t√≥pico anterior, mas, neste ponto, quero que voc√™s entendam que, dependendo do formato, compreender a forma como os n√∫meros s√£o escritos √© imprescind√≠vel.  Bin√°rio, como sabemos, √© basicamente a forma de escrever n√∫meros usando apenas 2 s√≠mbolos visuais diferentes, no caso, `0` e `1`.  J√° o decimal √© o sistema num√©rico mais comum, aquele que usamos no dia a dia. As quantidades s√£o escritas utilizando 10 s√≠mbolos visuais diferentes, em vez de apenas 2, como no bin√°rio.   Logo, quando aumentamos a quantidade de s√≠mbolos visuais dispon√≠veis para a escrita de uma quantidade, conseguimos representar quantidades maiores utilizando menos caracteres! Por exemplo, veja os n√∫meros que j√° usamos neste artigo: `11111111` e `255` representam exatamente a mesma quantidade nominal. Por√©m, a escrita bin√°ria exige mais d√≠gitos, pois h√° menos op√ß√µes para representar os valores. J√° no sistema decimal, precisamos de apenas 3 d√≠gitos para escrever essa mesma quantidade nominal (*duzentos e cinquenta e cinco*).  Al√©m desses dois formatos de escrita num√©rica, temos o *hexadecimal*, que usa 16 d√≠gitos diferentes para representar os n√∫meros. Talvez isso pare√ßa um pouco confuso, pois podemos nos perguntar:  > _**Q.:**_ _Se temos d√≠gitos de 0 a 9, com o que mais podemos completar at√© termos 16 d√≠gitos?_  A resposta √© simples: podemos usar letras!  Lembre-se de que os d√≠gitos visuais (os desenhos/glifos/caracteres) s√£o apenas s√≠mbolos para representar os n√∫meros. Poder√≠amos usar qualquer outra coisa. Imagine um sistema num√©rico que utilizasse todos os n√∫meros, todas as letras e ainda precisasse de mais s√≠mbolos... o que poder√≠amos usar? Sei l√°, talvez emojis kkkkkk üíÄ  Brincadeiras √† parte, no hexadecimal usamos os d√≠gitos de `0` a `9` e as letras de `A` a `F`.  Portanto, podemos representar a mesma quantidade nominal (*duzentos e cinquenta e cinco*) usando os tr√™s sistemas de numera√ß√£o: - **Bin√°rio**: `11111111`; - **Decimal**: `255`; - **Hexadecimal**: `FF`.  Antes de terminarmos esta se√ß√£o, √© comum usarmos alguns "prefixos" para indicar diferentes formas de escrita num√©rica. Inclusive, adotarei essa conven√ß√£o a partir de agora. Por exemplo, quando escrevemos um n√∫mero bin√°rio, utilizamos o prefixo `0b`, e para hexadecimal usamos `0x`. O resultado ficaria assim: - **Bin√°rio**: `0b11111111`; - **Decimal**: `255`; - **Hexadecimal**: `0xFF`.  Decimal n√£o precisa de prefixo, pois, sendo o padr√£o, assumimos automaticamente que um n√∫mero sem prefixo est√° em base decimal. Mas at√© que seria interessante termos um prefixo como "`0d255`"... Enfim, vamos avan√ßar.  ## 5.4 N√∫meros positivos e N√∫meros negativos  Vimos que 1 byte pode simplesmente guardar n√∫meros de [0b000000..0b111111]/[0..255]/[0x00..0xFF]. Mas e se... quisermos guardar o n√∫mero decimal -19?  Bom, com a explica√ß√£o que tivemos at√© agora, n√£o teria como. Por√©m, o que vimos foi a explica√ß√£o sobre n√∫meros **n√£o assinalados**, ou em ingl√™s, _**unsigned**_. Isso significa que tamb√©m temos uma representa√ß√£o **assinalada** (em ingl√™s, _**signed**_)!  > *Mas... por que existe essa coisa toda?*  A resposta √© que nem sempre temos necessidade de trabalhar com n√∫meros negativos. E, sabendo que muitos desses conceitos foram criados quando praticamente n√£o existia poder computacional, economizar qualquer m√≠sero bit j√° era obrigat√≥rio.  Ou seja, se a gente precisar de um n√∫mero negativo, qual a conclus√£o que temos? A conclus√£o √© que, de um jeito ou de outro, vamos precisar de algum artif√≠cio para guardar a informa√ß√£o de que tal n√∫mero √© negativo.  Ent√£o, a estrat√©gia encontrada, que foi a melhor para esse caso, foi justamente pegar os **8 bits** de 1 byte e reservar **1 deles** para guardar essa informa√ß√£o! Ent√£o, √© como se o n√∫mero bin√°rio m√°ximo fosse algo como 0b(0/1)1111111. Percebe que o bit mais √† esquerda ali eu coloquei como podendo ser 0 ou 1? Isso meio que faz com que a gente use esse bit para dizer se o n√∫mero √© negativo ou n√£o. Nesse caso, se esse bit for 0, o n√∫mero √© positivo; e se for 1, o n√∫mero √© negativo.  Por√©m, isso tem uma consequ√™ncia, e das grandes.  Se voc√™ observar, a gente meio que "desperdi√ßou" 1 bit dos 8 que t√≠nhamos para poder guardar a informa√ß√£o do "sinal". Isso significa que restaram apenas **7 bits** para escrever o n√∫mero! Vamos escrever esses 7 bits e ver o que teremos:  ``` 0b(0)1111111 -> 127 ```  Como voc√™ p√¥de ver, quando dizemos que trabalhamos com n√∫meros _**signed**_, isso implica dizer que vamos poder trabalhar apenas com metade do intervalo que t√≠nhamos no formato _**unsigned**_, que era 255.  Mas, como voc√™ tamb√©m p√¥de ver, 255 √© √≠mpar e n√£o tem metade exata. Portanto, o intervalo de bytes *signed* √© justamente de [-128..127] (em decimal).  De certa forma, ainda temos a mesma quantidade de itens que cabem dentro desse intervalo, os mesmos 255 itens. Por√©m, os valores m√°ximos s√£o reduzidos, pois primeiramente v√£o de [-128..0] e depois de [1..127].  ## 5.5 _"MSB"_ e _"LSB"_  Voc√™s podem se deparar bastante com essas siglas quando forem mexer com coisas de baixo n√≠vel assim. Para irmos direto ao ponto, _"MSB"_ significa _"most significant bit"_, ou "bit mais significativo". J√° o _"LSB"_ significa _"least significant bit"_, ou "bit menos significativo".  Na pr√°tica, isso serve para nos dizer qual √© o bit que mais "impacta" no valor de um n√∫mero. Por exemplo, considere este n√∫mero em bin√°rio:  ``` 0b1001101 ```  Se a gente considerar que a leitura do n√∫mero √© da esquerda para a direita (‚Üí), ent√£o o d√≠gito mais √† esquerda √© o _MSB_, enquanto o que est√° na ponta direita √© o _LSB_. Por√©m, se lermos no outro sentido, a conclus√£o seria o contr√°rio.  √â importante falarmos disso, pois cada documenta√ß√£o pode acabar considerando a escrita dos n√∫meros de um jeito ou de outro!  ## 5.6 N√∫meros se transformam em informa√ß√£o  Outro conceito absurdamente importante sobre a leitura de arquivos bin√°rios √© que, dependendo da especifica√ß√£o, devemos ler uma determinada quantidade de bytes e combin√°-los em um √∫nico n√∫mero para podermos extrair o significado desejado em tal ponto. Por exemplo, imagine que um arquivo bin√°rio hipot√©tico comece com os seguintes bytes:  ``` // estou escrevendo em hexadecimal aqui [0x2F, 0xDA, 0xE8, 0x22, ...] ```  Perceba que temos 4 itens (4 bytes) nessa sequ√™ncia. Por√©m, curiosamente, podemos extrair muito mais informa√ß√µes da√≠ do que apenas 4 coisas. *Como isso funciona?*  Podemos simplesmente ler uma determinada quantidade de bytes e combin√°-los em um n√∫mero maior no final. Veja, podemos ler os 2 primeiros bytes e escrever em um √∫nico n√∫mero assim: `0x2FDA`. Agora n√£o temos mais `1 byte`, mas sim `1 short`, afinal, como vimos, um short pode guardar at√© 16 bits, e como cada byte tem 8 bits, juntando 2 bytes em sequ√™ncia isso nos d√° um comprimento final de 16 bits!  Isso significa que os 2 primeiros bytes podem ter significado por si mesmos, assim como o n√∫mero resultante da leitura desses dois primeiros bytes tamb√©m pode ter algum outro significado.  > **Nota:** voc√™ pode converter os n√∫meros bin√°rios ou hexadecimais dos exemplos para decimal em alguma calculadora ou site online!  Dei o exemplo lendo 2 bytes, mas podemos ler 2, 3 ou mesmo os 4 bytes. Juntando os n√∫meros dessa forma, simplesmente podemos chegar a informa√ß√µes que n√£o necessariamente ficam restritas apenas aos bytes puros. Muitas vezes, as informa√ß√µes de que precisamos estar√£o em bytes √∫nicos, mas nem sempre. Dependendo da especifica√ß√£o do formato em quest√£o, a informa√ß√£o pode estar em sequ√™ncias como essas.  √â importante lembrar tamb√©m que, se a gente fizer a leitura de, por exemplo, 2 bytes, o n√∫mero resultante (no nosso exemplo anterior, `0x2FDA`) n√£o vai mais caber dentro de uma vari√°vel declarada com o tipo byte. Nesse caso, precisaremos de, pelo menos, um `short` para gravar esse n√∫mero.  ## 5.7 O tal _"endianess"_  O termo _endianess_ n√£o tem exatamente uma tradu√ß√£o para o portugu√™s, √© complicado traduzir isso. Ent√£o, vamos assumir que essa √© uma palavra em portugu√™s totalmente nova que voc√™ est√° conhecendo agora. ü§°  Quando a gente fala de *endianess*, estamos nos referindo √† ordem com que lidamos com os bytes. Por exemplo, vamos pegar aqueles bytes aqui de novo:  ``` [0x2F, 0xDA, 0xE8, 0x22, ...] ```  Se lermos os 2 primeiros bytes, podemos automaticamente escrev√™-los na seguinte ordem:  ``` 0x2FDA ```  Que √© justamente nossa ordem natural de leitura. Mas poder√≠amos simplesmente ler os bytes e escrev√™-los em outra ordem, olha s√≥:  ``` 0xDA2F ```  Percebe que, nesse segundo exemplo, eu escrevi o segundo byte da lista primeiro e, depois, o primeiro byte?  Isso, basicamente, √© o conceito de *endianess*, onde no primeiro caso temos o formato **BIG-ENDIAN**, ou seja, o nosso formato natural de leitura √© o *big-endian*, enquanto o segundo exemplo √© o **LITTLE-ENDIAN** (tipo ao contr√°rio).  Assim como o _MSB_ e o _LSB_ que vimos, o *endianess* tamb√©m serve para conven√ß√£o. Ent√£o, cada formato de seja l√° o que for pode ter suas pr√≥prias conven√ß√µes e regras baseadas nessas coisas.  ## 5.8 Opera√ß√µes de leitura  Para que consigamos fazer essas leituras, √© absurdamente obrigat√≥rio que saibamos as opera√ß√µes que usaremos para juntar, separar, obter e fazer todo tipo de manipula√ß√£o nos n√∫meros. Essas opera√ß√µes de baixo n√≠vel s√£o as opera√ß√µes _**bitwise**_, e, usando elas, podemos montar v√°rias opera√ß√µes de n√≠vel mais alto.  N√£o vou explicar a n√≠vel de _bit_ cada uma das opera√ß√µes, mas vamos ver as principais coisas que precisamos saber fazer usando _bitwise_.  ### 5.8.1 Juntar dois n√∫meros  Podemos ter dois n√∫meros e querer juntar ambos em um s√≥, assim como exemplificamos nos t√≥picos anteriores. Imagine que tenhamos os seguintes n√∫meros:  ``` numero_A = 0xAB numero_B = 0xCD ```  Se quisermos ter esses dois n√∫meros juntos em um s√≥, podemos simplesmente fazer:  ``` uniao = (numero_A << 8) | numero_B ```  E obtemos exatamente `uniao == 0xABCD`!  > _**Nota:**_ O n√∫mero `8` _hardcoded_ ali significa exatamente que primeiro fazemos um deslocamento _left shift_ (`<<`) de **8 bits**, sendo que 8 bits √© exatamente o **tamanho**, em _bits_, da vari√°vel `numero_A`. Obviamente, se o tamanho, em _bits_, dessa vari√°vel fosse outro, para fazer a uni√£o, dever√≠amos deslocar exatamente o tamanho em _bits_ que ela teria.  > _**Nota:**_ O operador `|` (l√™-se _"or"_) simplesmente junta dois n√∫meros!  > _E se tivermos 3 n√∫meros para serem unidos em 1 s√≥?_  Nesse caso, podemos fazer as opera√ß√µes por partes:  ``` numero_A = 0xAB numero_B = 0xCD numero_C = 0xEF  uniao_1 = (numero_A << 8) | numero_B uniao_2 = (uniao_1 << 16) | numero_C ```  Note que fizemos duas opera√ß√µes de uni√£o: primeiro unimos os dois primeiros n√∫meros, depois deslocamos o n√∫mero da uni√£o resultante (que, nesse ponto, j√° tinha o dobro do tamanho) e o unimos com o terceiro n√∫mero!  > _**Nota:**_ Observe que a ordem em que fazemos a uni√£o determina justamente o tal _**endianess**_! Do jeito que fiz nos exemplos, os n√∫meros est√£o na ordem de leitura "natural", logo, trata-se de _**BIG-ENDIAN**_, mas poder√≠amos tamb√©m ler esses bytes ao contr√°rio, gerando uma leitura em ordem _**LITTLE-ENDIAN**_.  # 6. Estrutura MIDI  Agora que fizemos uma boa introdu√ß√£o geral sobre leitura e um pouco sobre o formato MIDI em si, vamos, ent√£o, come√ßar a ver detalhes sobre a estrutura do arquivo.  Excepcionalmente, vou focar, em um primeiro momento, em detalhar a estrutura de uma forma mais textual, destacando as informa√ß√µes presentes em um arquivo. Vou colocar algumas informa√ß√µes sobre bytes nos t√≥picos a seguir, por√©m, o foco vai ser justamente entender quais s√£o essas informa√ß√µes e como elas est√£o presentes em um arquivo. Posteriormente, iremos fazer uma s√©rie de exemplos para vermos como os bytes s√£o usados para _codificar_ tais dados em um arquivo.  ## 6.1 _Chunks_  Assim como muitos outros formatos bin√°rios, o formato MIDI tamb√©m usa o conceito de _chunks_. Em portugu√™s, isso significa algo como "peda√ßos", o que faz sentido para as coisas que este formato se prop√µe a organizar.  Em termos gerais, um _chunk_ basicamente √© um grupo de coisas sequenciais do mesmo "tipo" que um arquivo pode guardar. Se pensarmos em programa√ß√£o, podemos fazer uma analogia considerando um _chunk_ como se fosse um "objeto". Assim, o arquivo MIDI √© composto por esses _objetos_.  O formato MIDI, portanto, cont√©m dois tipos de _chunks_, sendo eles um _chunk_ de cabe√ßalho (_header chunk_) e **um ou mais** _chunks_ de trilha (_track chunks_).  A seguir, vamos ver os detalhes sobre esses dois tipos de _chunks_.  ### 6.1.1 _Chunk_ de cabe√ßalho (_header_)  Esse _chunk_ √© bem simples de entender, pois serve para guardar informa√ß√µes gerais sobre o arquivo em quest√£o. As informa√ß√µes contidas em um _header chunk_ s√£o as seguintes:  | N√∫mero de bytes 	|         Dado        	| Tipo Esperado 	|                            Observa√ß√µes                            	| |:---------------:	|:-------------------:	|:-------------:	|:-----------------------------------------------------------------:	| |        4        	|      Assinatura     	|     Texto     	|                    **sempre** √© o valor `MThd`                    	| |        4        	| Tamanho do _header_ 	|     N√∫mero    	|    **sempre** √© o valor `0x0006`, ou simplesmente `6` (decimal)   	| |        2        	|  Formato do arquivo 	|     N√∫mero    	|        Esperamos ler um destes tr√™s n√∫meros: `0`, `1`, `2`        	| |        2        	|  N√∫mero de trilhas  	|     N√∫mero    	|          Quantidade de trilhas que o arquivo MIDI cont√©m          	| |        2        	|      "Divis√£o"      	|     N√∫mero    	| Resolu√ß√£o de tempo MIDI: ticks/sem√≠nima ou subdivis√µes SMPTE. 	|  > _**Nota:**_ Normalmente, em _headers_ como este, alguns campos de dados s√£o usados sem tantos prop√≥sitos, mas, ainda assim, podem servir para valida√ß√µes. Afinal, se um n√∫mero n√£o for lido como esperado, isso significar√° que ou o arquivo est√° "corrompido", ou foi "mal gravado", ou a leitura atual n√£o est√° sendo feita corretamente.  > _**Nota:**_ A documenta√ß√£o oficial menciona que os elementos presentes no _header_ podem ser expandidos no futuro. Ou seja, novas informa√ß√µes podem ser adicionadas conforme necess√°rio. Portanto, mesmo que um _header_ tenha dados que pare√ßam in√∫teis, √© importante l√™-los todos e verificar se fazem sentido em alguma vers√£o da documenta√ß√£o.  Essa tabela resume bem o conte√∫do de um _header_ MIDI. Vamos agora entender cada um dos itens.  #### 6.1.1.1 Assinatura (_MThd_)  Tipicamente, arquivos bin√°rios costumam ter essas coisas chamadas de "assinaturas" no meio dos seus bytes. Assinaturas podem ser qualquer coisa; neste caso, foi definido que seria um texto.  > _**Nota:**_ Curiosamente, se voc√™ abrir um arquivo MIDI em um bloco de notas, ser√° poss√≠vel ler essa assinatura (_"MThd"_) diretamente. Isso acontece porque esperamos justamente que os bytes correspondentes a esse dado representem um texto, e um programa como o Bloco de Notas faz exatamente isso: exibe o s√≠mbolo visual (caractere) para cada byte puro do arquivo. No entanto, se voc√™ abrir um MIDI no bloco de notas, ver√° muitos caracteres "aleat√≥rios" ou at√© mesmo s√≠mbolos como um "quadrado". Isso ocorre porque nem todos os valores de bytes possuem um caractere visual associado a eles em qualquer esquema de mapeamento, como o padr√£o `UTF-8`. Por√©m, renderizando os bytes com outro _**charset**_, √© poss√≠vel obter resultados totalmente diferentes.  No arquivo MIDI, a assinatura de um _chunk_ de cabe√ßalho sempre ser√° a _string_ `MThd`, que √© formada pela seguinte sequ√™ncia de bytes:  ``` [0x4D, 0x54, 0x68, 0x64, ...] ```  Portanto, ao ler cada byte separadamente e convert√™-lo para um tipo `char`, vemos que os quatro formam a _string_ `MThd`.  > _**Nota:**_ Isso equivale a simplesmente verificar qual √© o valor desse n√∫mero (o byte) na tabela _ASCII_.  Portanto, todo arquivo MIDI come√ßa exatamente com essa sequ√™ncia. Se carregarmos o arquivo em um _array_, conforme descrito no item [Ponto de partida](#51-ponto-de-partida) deste artigo, podemos extrair a assinatura do cabe√ßalho nos primeiros quatro itens do array.  #### 6.1.1.2 Tamanho do _header_  A especifica√ß√£o define este campo para indicar o tamanho do _header_, em bytes. Excluindo os bytes usados na assinatura (4), os restantes somam 6 bytes. Logo, sempre devemos esperar ler o n√∫mero 6 para este campo.  Caso a documenta√ß√£o venha a incluir mais dados no _header_, esse valor certamente mudar√°.  #### 6.1.1.3 Formato do arquivo  Curiosamente o formato MIDI meio que... possui _sub-formatos_. üíÄ  Mas n√£o se preocupe, n√£o √© t√£o complicado assim. Esse formato que lemos aqui basicamente define algumas regras sobre a organiza√ß√£o dos _chunks_ de trilha. Veja s√≥ esta tabela resumo:  | Formato 	|                                                                              Descri√ß√£o                                                                             	| |:-------:	|:------------------------------------------------------------------------------------------------------------------------------------------------------------------:	| |   `0`   	|                                      O arquivo MIDI ter√° apenas uma √∫nica trilha; apenas um √∫nico _chunk_ de trilha √© esperado                                     	| |   `1`   	| O arquivo MIDI pode conter uma ou mais trilhas que funcionam **simultaneamente**. Para este formato, a primeira trilha **obrigatoriamente** conter√° metadados. 	| |   `2`   	|                                                O arquivo MIDI ter√° uma ou mais trilhas sequencialmente independentes.                                                	|  Como voc√™ p√¥de ver, os formatos descrevem coisas bem simples sobre as trilhas, mas para detalhar mais um pouco, veja s√≥:  - **Formato 0**: cont√©m um √∫nico *track chunk* ap√≥s o *header chunk*. Ele √© simples e muito compat√≠vel, sendo ideal para programas b√°sicos que precisam tocar um √∫nico canal de som, como sintetizadores simples ou sistemas focados em efeitos sonoros. Mesmo que seu software utilize m√∫ltiplas trilhas, pode ser √∫til oferecer suporte ao Formato 0 para garantir compatibilidade com programas mais simples.  - **Formato 1**: cont√©m m√∫ltiplos *track chunks* organizados como trilhas simult√¢neas. Esse formato √© ideal para softwares que trabalham com v√°rias faixas ao mesmo tempo, como sequenciadores de √°udio. A primeira trilha sempre cont√©m informa√ß√µes de tempo e outros metadados essenciais.  - **Formato 2**: tamb√©m cont√©m m√∫ltiplos *track chunks*, mas eles representam padr√µes independentes em vez de trilhas sincronizadas. √â √∫til para programas que organizam m√∫sica de forma modular, permitindo a manipula√ß√£o de diferentes segmentos separadamente. Esse formato √© menos comum e geralmente usado para bancos de padr√µes musicais.  Para garantir compatibilidade entre dispositivos e softwares, √© essencial que os arquivos MIDI incluam informa√ß√µes sobre **tempo e compasso**. Caso contr√°rio, assume-se um compasso 4/4 e um tempo de 120 BPM. Essas informa√ß√µes devem estar no primeiro *track chunk* de arquivos nos formatos 1 e 2, e no in√≠cio da √∫nica trilha em arquivos no Formato 0.  No futuro, novos formatos podem surgir. Por isso, √© importante que os programas lidem com IDs desconhecidos de forma flex√≠vel, aproveitando os *track chunks* dispon√≠veis. Al√©m disso, o *header chunk* pode ganhar novos par√¢metros, ent√£o os leitores de arquivos MIDI devem sempre considerar seu tamanho ao process√°-lo.  #### 6.1.1.4 N√∫mero de trilhas (_`ntrks`_)  Um outro dado que existe no _header_ √© basicamente autoexplicativo: mostra exatamente quantas trilhas o arquivo MIDI tem. Al√©m disso, a documenta√ß√£o oficial chama isso de "_`ntrks`_", ent√£o √© importante voc√™ ter esse pequeno detalhe em mente, caso v√° ler a documenta√ß√£o oficial tamb√©m.  Mesmo esse campo sendo basicamente trivial de se entender, √© interessante vermos algumas particularidades sobre esse n√∫mero ‚Äî em especial, como exatamente ele se relaciona com o valor do t√≥pico anterior: o _formato do arquivo_:  - Em um arquivo MIDI de formato `0`, o campo `ntrks` ser√°, logicamente, lido com valor `1`, j√° que um arquivo de trilha √∫nica ter√°, em termos l√≥gicos, apenas uma trilha; - Um arquivo MIDI de formato `1` ou `2` ter√°, logicamente, o campo `ntrks` maior que `1`.  > _**Nota:**_ Se um MIDI de tipo `1` ou `2` tem apenas 1 trilha, obrigatoriamente deve-se esperar que haja uma trilha extra de metadados. Ou seja, sempre que um MIDI n√£o for de tipo `0`, espera-se que o valor lido em `ntrks` seja maior que `1`. Qualquer inconsist√™ncia na rela√ß√£o dos valores lidos desses dois campos implica em algum problema de leitura, corrup√ß√£o do arquivo ou m√° grava√ß√£o do mesmo.